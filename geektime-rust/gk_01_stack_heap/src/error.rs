/*
首先，你使用起来就会感受到，Rust 是一门非常重视开发者用户体验的语言(最基本的要求
就是控制缺陷) 漏斗
语法缺陷 -- RA  
类型安全缺陷 -- 类型系统
内存和资源安全缺陷 -- 所有权/j借用检查/生命周期
并发安全缺陷 -- 所有权/j借用检查/生命周期 + 类型系统
错误处理的缺陷 --编译期告警
代码的格式 cargo fmt/clippy, linting，到 code review，
再到（逻辑缺陷）单元测试、（功能缺陷）集成测试、（用户体验缺陷）手工测试

引入缺陷的代价， 尽可能把大量缺陷在编译期，在秒和分钟级就替你检测出来，让你修改  前期和编译期做斗争, 面向编译期编程

其次，众所周知的优异性能和强大的表现力，让 Rust 在很多场合都能够施展拳脚
最后，是我自己的使用感觉，Rust 会越用越享受

go/rust模式 go 开发效率, rust 性能解决内存的过高占用以及cpu密集型计算的场景, 如tidb
一门语言不能解决所有问题
从其他语言迁移到 Rust，必须要经过一段时期的思维转换（Paradigm Shift）, 变量的所有权和生命周期
每种语言都有它们各自的优劣和适用场景，谈不上谁一定取代谁。社区的形成、兴盛和衰亡是一个长久的过程


Pascal 尼古拉斯·沃斯（Niklaus Wirth）算法 + 数据结构 = 程序。
想随心所欲地使用 Rust 为你的系统构建数据结构，深度掌握类型系统必不可少


费曼总结过他的学习方法，评价和分享 / 教授给别人是非常重要的步骤，能让你进一步巩固自己学到的知识和技能

第一性原理：回归事物最基础的条件，将其拆分成基本要素解构分析，来探索要解决的问题。


使用 Trait 做接口设计、使用泛型做编译期多态、使用 Trait Object 做运行时多态

unsafe rust 在编译器做的严格检查退步成为 C++ 的样子

Rust里循环引用就会内存泄漏（比如用RefCell<Rc<T>>），但简单的循环引用只要是ma
rk-and-sweap的GC都可以处理 引用计数引发的循环引用，可以用 weak 解决
https://doc.rust-lang.org/std/rc/struct.Weak.html


Rust 适合计算密集型的任务

*/

// cargo build --bin error
fn main() {
    let name = "HelloWorld".to_string();
    // 隐含着线程不安全的访问, 对于编译错误，Rust 编译器会给出详细的错误原因，并给出建议的修复方法
    // 当前线程持有的变量 name 可能在新启动的线程使用之前就被释放，发生 use after free
    // std::thread::spawn( || {
    std::thread::spawn( move || {
        println!("hello1 {}", name);
    });
}
